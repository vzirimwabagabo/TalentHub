middlewares


// src/middlewares/authMiddleware.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.protect = async (req, res, next) => {
    let token;

    if (
        req.headers.authorization &&
        req.headers.authorization.startsWith('Bearer')
    ) {
        try {
            // Get token from header
            token = req.headers.authorization.split(' ')[1];

            // Verify token
            const decoded = jwt.verify(token, process.env.JWT_SECRET);

            // Attach user object to request
            req.user = await User.findById(decoded.id).select('-password');

            if (!req.user) {
                return res.status(401).json({ success: false, message: 'Not authorized, user not found' });
            }

            next();
        } catch (error) {
            console.error('Token verification failed:', error);
            return res.status(401).json({ success: false, message: 'Not authorized, token failed' });
        }
    }

    if (!token) {
        return res.status(401).json({ success: false, message: 'Not authorized, no token' });
    }
};

exports.adminOnly = (req, res, next) => {
    if (req.user && req.user.role === 'admin') {
        next();
    } else {
        res.status(403).json({ success: false, message: 'Access denied: Admins only' });
    }
};



// src/middlewares/errorHandler.js

exports.errorHandler = (err, req, res, next) => {
    console.error('Error:', err.stack);

    const statusCode = res.statusCode !== 200 ? res.statusCode : 500;

    res.status(statusCode).json({
        success: false,
        message: err.message || 'Internal Server Error',
        stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
};

// src/middlewares/ malwareScan.js
// For demonstration; in production, use clamav.js or a cloud scanner
module.exports = (req, res, next) => {
  if (!req.file) return next();
  // Simulate scan
  const isMalicious = false; // Replace with real scan check
  if (isMalicious) {
    return res.status(400).json({ success: false, message: 'Uploaded file failed malware scan.' });
  }
  next();
};

// src/middlewares/uploadMiddleware.js
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Define base upload directory relative to project root
const UPLOAD_ROOT = path.join(__dirname, '../../uploads');

// Ensure main uploads folder exists
if (!fs.existsSync(UPLOAD_ROOT)) {
  fs.mkdirSync(UPLOAD_ROOT, { recursive: true });
}

// Full path for portfolio files
const PORTFOLIO_PATH = path.join(UPLOAD_ROOT, 'portfolio');
if (!fs.existsSync(PORTFOLIO_PATH)) {
  fs.mkdirSync(PORTFOLIO_PATH, { recursive: true });
}

// Supported file type checks
function isValidFileType(file) {
  const ext = path.extname(file.originalname).toLowerCase();
  const mime = file.mimetype;

  // Image: jpeg, png, gif, webp
  if (mime.startsWith('image/') || ['.jpg', '.jpeg', '.png', '.gif', '.webp'].includes(ext)) {
    return 'image';
  }

  // Video: mp4, mov, webm, etc.
  if (mime.startsWith('video/') || ['.mp4', '.mov', '.webm', '.avi', '.flv'].includes(ext)) {
    return 'video';
  }

  // PDF
  if (mime === 'application/pdf' || ext === '.pdf') {
    return 'pdf';
  }

  return null;
}

// Custom Storage Engine
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    console.log("Destination requested:", file);
    cb(null, PORTFOLIO_PATH); // Save to /uploads/portfolio
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1E9)}`;
    cb(null, `refutalent_${uniqueSuffix}${ext}`);
  }
});

// File Filter
const fileFilter = (req, file, cb) => {
  const fileType = isValidFileType(file);

  if (!fileType) {
    return cb(new Error('Only images, videos, and PDFs are allowed.'), false);
  }

  // Pass metadata to controller via request
  req.fileType = fileType; // e.g., 'image', 'video', 'pdf'
  cb(null, true);
};

// Multer instance with limits
const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 50 * 1024 * 1024 // 50 MB max
  }
});

module.exports = upload;


// src/middlewares/validateRequest.js
const { validationResult } = require("express-validator");

module.exports = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(422).json({
      success: false,
      errors: errors.array().map((err) => ({
        field: err.param,
        message: err.msg,
      })),
    });
  }
  next();
};


// src/middlewares/validation.js
const { body } = require("express-validator");

// Registration validation
exports.registerValidation = [
  body("name").notEmpty().withMessage("Name is required"),
  body("email").isEmail().withMessage("Valid email is required"),
  body("password")
    .isLength({ min: 6 })
    .withMessage("Password must be at least 6 characters"),
];

// Login validation
exports.loginValidation = [
  body("email").isEmail().withMessage("Valid email is required"),
  body("password").notEmpty().withMessage("Password is required"),
];

// Forgot password validation
exports.forgotPasswordValidation = [
  body("email").isEmail().withMessage("Valid email is required"),
];

// Reset password validation
exports.resetPasswordValidation = [
  body("password")
    .isLength({ min: 6 })
    .withMessage("Password must be at least 6 characters"),
];

// ✅ TALENT PROFILE VALIDATIONS — YOU WERE MISSING THESE!
exports.createTalentProfileValidation = [
  body('bio')
    .notEmpty()
    .withMessage('Bio is required'),
  body('skills')
    .optional()
    .isArray()
    .withMessage('Skills must be an array'),
  body('headline')
    .optional()
    .isString()
    .isLength({ max: 100 })
    .withMessage('Headline must be under 100 characters')
];

exports.updateTalentProfileValidation = [
  body('bio')
    .optional()
    .isString(),
  body('skills')
    .optional()
    .isArray(),
  body('headline')
    .optional()
    .isString()
    .isLength({ max: 100 })
];


